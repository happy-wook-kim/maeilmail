## 이벤트 버블링과 캡처링에 대해 설명해주세요.

DOM 요소에서 이벤트가 발생하면 이벤트는 다음의 3단계를 거쳐 전파됩니다.
1. **캡처링 단계** : 이벤트가 최상위 객체에서 시작하여 실제 이벤트가 발생한 타겟 요소까지 DOM 트리를 따라 내려갑니다.
2. **타겟 단계** : 이벤트가 실제 타겟 요소에 도달하여 해당 요소에 등록된 이벤트 리스너가 실행됩니다.
3. **버블링 단계** : 이벤트가 타겟 요소에서 시작하여 다시 DOM 트리를 따라 최상위 객체까지 올라옵니다.

### 이벤트 버블링
이벤트 버블링은 이벤트가 발생했을 때 가장 안쪽의 타켓 요소에서 시작하여 DOM 트리를 따라 부모 요소로 순차적으로 이벤트가 전파되는 방식입니다.
예를 들어 버튼을 클릭했을 때 버튼 자체에서 이벤트가 발생한 후 이 이벤트가 상위 요소인 div, body, document, window로 전파되는 과정을 거칩니다.

브라우저는 기본적으로 이벤트 전파를 버블링 단계에서 처리하도록 설계되어 있습니다.

### 이벤트 캡처링
이벤트 캡처링은 이벤트 버블링과 반대 방향으로 진행됩니다. 
이벤트가 최상위 부모 요소에서 시작하여 실제 이벤트가 발생한 타겟 요소까지 DOM 트리를 따라 내려가면서 이벤트가 전파됩니다.
예를 들어 window에서 이벤트가 시작되어 document, body, div를 거쳐 버튼에 도달하게 되는 방식입니다.

기본적으로 이벤트 리스너는 캡처링 단계에서 이벤트를 감지하지 않습니다.
캡처링 단계에서 이벤트를 처리하려면 `addEventListener`함수의 세 번째 인자로 `{ capture: true }`를 전달해야 합니다.

### 활용 사례
버블링과 캡처링은 각각의 특성을 활용하여 다양한 상황에서 유용하게 사용됩니다.

#### 버블링을 활용한 이벤트 위임(Event Delegation)
이벤트 위임은 여러 자식 요소들의 이벤트를 각각의 자식 요소에서 개별적으로 등록하지 않고 상위 부모 요소 하나에만 이벤트 리스너를 등록하여 관리하는 패턴입니다.
#### 장점
* 동적 요소 관리 : 새롭게 추가되거나 삭제되는 자식 요소들에 대해 일일이 이벤트 리스너를 추가하거나 제거할 필요가 없습니다.
* 성능 향상 : 이벤트 리스너의 수를 줄여 메모리 사용량을 줄이고 초기 로딩 속도를 개선할 수 있습니다.

#### 주의 사항
부모 요소에 등록된 리스너 내에서 실제 이벤트가 발생한 요소를 식별해야합니다. 이때 `event.target`속성을 사용합니다. `event.currentTarget`은 리스너가 부착된 요소를 가리킵니다.
```
// 이벤트 위임 예시 (ul 리스트의 li 아이템 클릭 처리)
const itemList = document.getElementById('itemList'); // <ul> 요소

itemList.addEventListener('click', function(event) {
  // event.target은 실제 클릭된 요소를 가리킴 (예: <li> 또는 <li> 안의 <span>)
  // event.currentTarget은 리스너가 부착된 요소, 즉 <ul>을 가리킴
  if (event.target.tagName === 'LI') {
    console.log('클릭된 아이템:', event.target.textContent);
  }
});
```

#### 캡처링을 활용한 우선적 이벤트 처리 및 전역 핸들링
캡처링은 특정 이벤트가 자식 요소에 도달하기 전 부모 요소에서 먼저 가로채 처리할 때 유용합니다.

특정 이벤트가 발생했을 때 페이지 전체의 사용자 행동을 분석 및 로깅을 하위 요소의 특정 동작과 관계없이 최상위 레벨에서 먼저 기록할 수 있습니다.
특정 영역 내 이벤트의 기본 동작을 일괄적으로 막거나, 특정 조건에 따라 이벤트 전파를 차단할 때 사용할 수 있습니다.

### 이벤트 전파 제어
* `event.stopPropagation()` : 현재 이벤트 이후의 전파 단계를 중단합니다. 버블링 단계에서 이 메서드가 호출되면 더 이상 상위 요소로 이벤트가 전파되지 않습니다.
* `event.preventDefault()` : 이벤트의 기본 동작을 취소합니다. 예를 들어 `<a>`클릭 시 페이지 이동을 막거나 `<form>`제출 시 페이지 새로고침을 막는데 사용합니다.
* `event.stopImmediatePropagation()` : `stopPropagation()`과 유사하지만 한 단계 더 나아가 현재 요소에 등록된 다른 이벤트 리스너들의 실행까지도 중단시킵니다.

### 주의 사항 및 잠재적 문제점
* **이벤트 중첩으로 인한 동일 이벤트 중복 처리** : 한 요소에 동일한 이벤트 리스너가 여러 번 등록되거나 부모와 자식 모두 특정 로직을 수행하는 리스너가 있을 때 발생할 수 있습니다.
`stopPropagation()`을 적절히 사용하거나 리스너 등록 로직을 신중하게 설계하여 방지할 수 있습니다.
* **캡처링 단계에서 불필요한 이벤트 처리로 인한 성능 문제** : 너무 광범위한 요소에 캡처링 리스너를 등록하고 모든 이벤트를 처리하려고 하면 성능에 부담을 줄 수 있습니다.
필요한 경우에만 특정 영역에 캡처링을 사용하고 이벤트 처리 로직을 최대한 가볍게 유지해야 합니다.
* **이벤트 위임 시 타겟 오작동** : `event.target`을 정확히 확인하지 않아 발생합니다. 클릭된 요소가 의도한 타겟 요소인지 혹은 타겟 요소의 자식인지 등을 명확히 구분해야합니다.

### 결론
이벤트 버블링과 캡처링은 JavaScript 이벤트 모델의 핵심입니다.
위 두 가지 전파 방식을 이해하고 `addEventListner`의 옵션 `event.target` `event.currentTarget` `event.stopPropagation()`을 적절히 활용하면 더욱 유연하고 효율적인 이벤트 핸들링 로직을 구현할 수 있습니다.
이는 복잡한 웹 애플리케이션을 개발할 때 코드의 품질과 성능을 높이는데 크게 기여합니다.
