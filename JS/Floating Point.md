## 자바스크립트에서 "0.1 + 0.2 === 0.3"의 실행 결과에 대해 설명해주세요.

자바스크립트에서 0.1 + 0.2 === 0.3은 `false` 입니다. 
그 이유는 자바스크립트가 부동소수점을 처리하는 방식에 있습니다.

자바스크립트에서 숫자를 국제 표준인 IEEE 754 형식인 64비트 부동소수점으로 저장하고 연산합니다. 
`0.1` `0.2`와 같은 2진수는 정확하게 이진수로 변환할 수 없는 무한 소수가 됩니다. 컴퓨터는 이를 근사값으로 저장합니다.
이로 인해 0.1 + 0.2의 실제값은 0.30000000000000004가 됩니다.

### 해결 방법
가장 단순한 해결법은 특정 자리수까지 반올림하는 것입니다. 
```
// 문자열로 비교
console.log((0.1 + 0.2).toFixed(1) === '0.3'); // true

// 숫자로 비교
console.log(Math.round((0.1 + 0.2) * 10) / 10 === 0.3); // true
```

또는 `Number.EPSILON`을 활용하여 비교합니다. `Number.EPSILON`은 자바스크립트에서 표현할 수 있는 가장 작은 수 입니다. 
```
function isEqual(num1, num2) {
  return Math.abs(num1 - num2) < Number.EPSILON;
}

console.log(isEqual(0.1 + 0.2, 0.3)); // true
```

### 오차가 발생함에도 자바스크립트가 부동소수점 표준을 채택한 이유는?
1. **하드웨어 효율성 및 성능** : 현대의 거의 모든 CPU와 FPU(부동소수점 장치)는 IEEE 754 표준에 맞춰 설계되었고 이 형식의 연산을 하드웨어 수준에서 매우 빠르게 처리하도록 최적화 되어있습니다.
2. **표준화 및 상호 운용성** : IEEE 754는 컴퓨터 과학 분야에서 부동소수점 표현과 연산에 대한 사실상의 표준입니다.
3. **넓은 표현 범위** : 64비트를 사용하여 매우 작은 수부터 매우 큰 수까지 아주 넓은 범위의 숫자를 표현할 수 있습니다.
4. **메모리 효율성** : 64비트라는 고정된 크기로 저장하므로 메모리 관리가 비교적 단순하고 예측 가능합니다.
