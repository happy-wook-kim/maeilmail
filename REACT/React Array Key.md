## 리액트에서 index를 key값으로 사용하면 안되는 이유에 대해서 설명해주세요.

리액트에서 배열을 `map()` 메소드 등으로 순회하여 리스트 형태의 UI를 렌더링할 때, 각 요소에 고유한 `key`를 지정해야합니다.
리스트에 항목이 추가되거나 삭제 또는 재정렬 되는 등의 변경이 있을 때, **어떤 항목이 변경되었고 어떤 항목이 그대로 유지되는지를 효율적으로 파악하기 위해** `key`를 사용합니다.
`key`를 통해 각 리스트 항목을 고유하게 식별하는데 사용하며 리액트에서 이전 렌더링과 현재 렌더링 사이 동일한 항목을 추적할 수 있게 합니다.

### index를 사용하면 안되는 이유

* 리스트 항목 추가/삭제 시 문제 발생
배열의 시작이나 중간에 새 항목이 추가되거나 기존 항목이 삭제되면 그 뒤에 오는 모든 항목들의 인덱스가 변경됩니다.
리액트는 `key`값이 같으면 같은 인스턴스라고 가정하고 내용을 업데이트합니다.
key={0}이 'A'였지만 배열 가장 앞자리에 'X'가 추가되는 경우 key={0}은 'X' key={1}이 'A'가 됩니다.
컴포넌트가 내부 상태를 가지고 있다면 'A'컴포넌트의 상태가 'X'컴포넌트에게 주어고 'B'컴포넌트의 상태가 'A'컴포넌트에게 잘못 전달 될 수 있습니다.
**데이터 표시에 오류**가 생기고 **상태 관리에 버그**가 생길 수 있습니다.

* 리스트 항목 재정렬 시 문제 발생
위 오류와 마찬가지로 key={0}이 'A'를 key={1}이 'B'로 인식하고 있을때 A, B 위치가 바뀌게 되면 'A'컴포넌트를 'B', 'B'컴포넌트를 'A'로 업데이트하려고 시도할 수 있습니다.
이로인해 **불필요한 DOM 조작**과 **상태 문제**가 발생할 수 있습니다. 리액트는 항목이 재정렬됐다는 것을 `key`만으로는 알 수 없습니다.

* 필터링/검색 기능 구현 시 문제 발생
사용자의 입력에 따라 리스트가 필터링되면서 배열의 내용과 길이가 계속 변하고 이에 따라 인덱스도 계속 변경됩니다. 위에 설명한 문제들을 지속적으로 발생하게 합니다.

### 결론

리스트가 동적으로 변하더라도 `key`는 동적으로 변해서는 안됩니다. 고유한 값을 사용해야 합니다.
```
// 유일한 값인 id을 사용
items.map((item) => <ListItem key={item.id} data={item} />);
```

